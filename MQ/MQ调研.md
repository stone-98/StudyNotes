## 对比

综合对比Kafka、RabbitMQ、RocketMQ、ActiveMQ这4款当前主流的MQ消息中间件产品。

| 对比指标\消息队列名称 | Kafka | RabbitMQ |RocketMQ |ActiveMQ |
|-------------|--------|---------|--------|--------|
| 资料文档        | 中等 | 	多 | 	少 | 多 |
| 开发语言        | Scala | Erlang | Java | Java |
| 支持的协议        | 自定义（基于TCP） | AMQP | 自定义 | 	OpenWire、STOMP、REST、XMPP、AMQP |
| 消息存储        | 内存、磁盘、数据库；支持大量堆积 | 内存、磁盘；支持少量堆积 | 磁盘；支持大量堆积 | 内存、磁盘、数据库；支持少量堆积 |
| 消息事务        | 支持 | 支持 | 支持 | 支持 |
| 负载均衡        | 支持 | 支持的不好 | 支持 | 可基于zookeeper实现负载均衡 |
| 集群方式        | 	天然的‘Leader-Slave’无状态集群 | 支持简单集群 对高级集群模式支持不好 | 常用 多对'Master-Slave' 模式 | 支持简单集群模式对高级集群模式支持不好 |
| 管理界面        | 一般 | 好 | 好 | 一般 |
| 可用性        | 	非常高（分布式） | 高（主从） | 非常高（分布式） | 高（主从） |
| 消息重复        | 	支持at least once、at most once | 支持at least once、at most once | 支持at least once | 支持at least once |
| 吞吐量TPS        | 极大 | 比较大 | 	大 | 比较大 |
| 订阅形式和消息分发        | 发布订阅模式 | direct、topic、Headers和fanout | 发布订阅模式 | 模式	点对点(p2p)、广播（发布-订阅） |
| 顺序消息        | 支持 | 不支持 | 支持 | 支持 |
| 消息确认        | 支持 | 支持 | 支持 | 支持 |
| 消息回溯        | 支持指定分区offset位置的回溯 | 不支持 | 	支持指定时间点的回溯 | 不支持 |
| 消息重试        | 不支持 | 不支持 | 支持 | 不支持 |

## 总结

一般业务系统如果需要引入MQ，在最早的时候大家都使用ActiveMQ，但是对于Active现在大家使用的不多了，并且它没有经过大规模的吞吐量场景的验证，现在的社区也不是很活跃，所以我个人的话是不推荐它了。

后来慢慢的大家开始使用RabbitMQ，但是Erlang语言阻止了大量的JAVA工程师去深入研究和掌控它，对于公司而言，几乎处于不可控的状态，但是确认RabbitMQ是开源的，有比较稳定的支持，社区活跃度也高，如果对可用性以及业务没有那么复杂的场景下，是一个不错的选择。

现在越来越多的人使用RocketMQ，确实RocketMQ各个方面的支持都比RabbitMQ好，但是要想好有社区突然黄掉的可能性，当然了如果对于大公司的基础架构研发能力足够强的话，RocketMQ是一个很好的选择。

如果是大数据领域的实时计算、日志采集的场景用Kafka是业内的标准，社区活跃度也很高，不会黄，何况几乎是全世界这个领域的事实性规范。

像我们的话，第一个肯定舍弃ActiveMQ，对于RabbitMQ的话因为由于历史原因，之前就一直使用的是RabbitMQ，组员对RabbitMQ都比较熟悉，也不会有相关的场景去定制化MQ，吞吐量的话RabbitMQ也是可以接受的，所以就一直采用的是RabbitMQ。

如果对于刚起步阶段的话，如果你的应用对吞吐量、低延迟有较高的要求，那么Kafka是最好的选择，如果你的业务场景需要更加灵活的消息投递模式以及强大的过滤功能，RocketMQ可能更加合适。