# 分布式事务的解决方案

## 前提

首先您应该具备了解事务的ACID特性。

## 分布式事务

分布式事务顾名思义就是在分布式系统中实现事务，它由多个本地事务组合而成。

## 2PC

2PC（Two-phase commit protocol）中文叫做二阶段提交，二阶段提交是一种强一致性设计，2PC引入了一个事务协调者的角色来协调管理各参与者的提交和回滚。

二阶段分别指的是：

- 准备阶段
- 提交阶段

下面我们看看两个阶段的具体流程：

- **准备阶段**协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完了。
- 同步等待所有资源的响应之后就进入第二阶段即提交阶段（注意提交阶段不一定是提交事务，也可能是回滚事务）。

假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。

下面是具体的流程图：

![image-20230625110321598](https://gitee.com/stone-98/picture-bed/raw/master/202306251104898.png)

假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败。

![image-20230625110422090](https://gitee.com/stone-98/picture-bed/raw/master/202306251104171.png)

关于2PC的具体流程上述也讲解的查不多了，但是还有以下的一些思考。

### 思考

#### 如果第二阶段提交失败

那么事务协调者应当不断的进行重试。否则一直阻塞，需要人工介入处理。

首先2PC是一个同步阻塞协议，想第一阶段协调者会等待所有参与者响应才会执行下一步操作，当然第一阶段有超时机制，假设应为网络原因没有收到某参与者的响应或参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令，但是在第二阶段没有超时机制，因此我们分析事务协调者只有不断的进行重试。

## 3PC



## 本地消息表

本地消息表其实就是利用了各系统的本地事务来保证分布式事务。

本地消息表顾名思义就是会有一张存放本地消息的表，一般都是存放在数据库中，然后在具体执行业务时，将业务的处理和本地消息表的入库放入同一个本地事务中，这样就能保证本地事务表中的业务一定是执行成功的。

接下来再去调用下一步的业务，如果一个业务成功了，那么本地消息表中对应的数据状态改成已成功。

否则，通过后台任务定时去查询本地表中失败的业务进行重试，由于有重试机制，则需要保证对应的服务方法的幂等性。

当重试到达最大次数之后，如果还未成功，则需要人工介入处理。

从以上的叙述总结，本地消息表其实实现的是数据最终的一致性，容忍了数据暂时不一致的情况。

## RocketMQ的消息事务

RocketMQ很好的支持了消息事务，RocketMQ消息事务的主要流程如下：

- 第一步先给Broker发送事务消息即半消息，半消息是指这个消息对消费者来说是不可见的，发送成功后再执行本地事务。
- 再根据本地事务的结果向Broker发送Commit和RollBack命令。
- 并且RocketMQ的发送方提供一个反查事务状态的接口，如果一段时间内半消息没有收到任何操作请求，那么Broker会通过反查事务状态接口查询发送方事务是否执行成功，然后执行Commit或者RollBack命令。

- 如果这条消息执行了Commit操作，那么订阅方则对这条消息进行处理。
- 如果执行了Rollback那么订阅方收不到这条消息，那么就是事务执行没通过。

流程图如下：

![image-20230625135901796](https://gitee.com/stone-98/picture-bed/raw/master/202306251359088.png)

[基于RocketMQ解决分布式事务的Demo](https://juejin.cn/post/6844904099993878536)