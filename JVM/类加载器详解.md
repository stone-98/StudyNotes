
## 类加载过程：

- 加载：在加载阶段，类加载器会根据类的全限定类名在文件系统中或者网络系统中查找对于的class文件，并且将他读入到内存中，在读入的过程中，虚拟机会对.class文件进行校验，以确保该文件的格式符合Java虚拟机规范，防止恶意代码的注入。
- 链接
  - 验证：对类的字节码进行校验，以确保字节码符合Java虚拟机规范。主要包含一下四个方面的校验：
    - 文件格式校验
    - 元数据校验
    - 字节码验证
    - 符号引用验证
  - 准备：为类的静态变量分配内存，并设置初始值。这些变量会在此时被赋值为0（数值类型）或null（引用类型）。
  - 解析：将类的符号引用转换为直接引用。
- 初始化：初始化阶段，虚拟机会按照程序员指定的顺序执行类的静态代码块或赋值语句。同事，虚拟机会保证同一时刻只有一条线程执行该类的初始化操作，以避免竞态条件的发生。

需要注意的是，类的初始化是一个主动的过程，只有在以下条件才会触发类的初始化：
- 创建该类的实例；
- 访问该类的静态变量或静态方法；
- 使用反射方式访问该类；
- 该类是程序的入口类；


## 双亲委派策略的执行流程

双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 java.lang.ClassLoader 的 loadClass() 中，相关代码如下所示：

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //首先，检查该类是否已经加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果 c 为 null，则说明该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //当父类的加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                } else {
                    //当父类的加载器为空，则调用启动类加载器来加载该类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //非空父类的类加载器无法找到相应的类，则抛出异常
            }

            if (c == null) {
                //当父类加载器无法加载时，则调用findClass方法来加载该类
                //用户可通过覆写该方法，来自定义类加载器
                long t1 = System.nanoTime();
                c = findClass(name);

                //用于统计类加载器相关的信息
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
}

```
上述这段代码实现了类加载器的加载过程和链接过程，类的初始化过程是再生成class对象之后，首次对类进行主动使用进行的。