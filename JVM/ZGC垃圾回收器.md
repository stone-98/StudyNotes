## 背景

ZGC收集器（Z Garbage Collector）是由Oracle公司研发的。2018年创建了JEP 333将ZGC提交给OpenJDK，推动其进入OpenJDK11的发布清单中。

## 介绍

ZGC垃圾收集器是一款基于Region内存布局的，暂未设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，以低延迟为首要目标的一款垃圾收集器。

## 实现目标

- JDK推出的一款低延迟垃圾回收器
- 支持4TB级别的堆（JDK13已支持到了16TB）
- 停顿时间不会超过10ms，且不会随着堆的大小增加而增加

## ZGC的堆内存布局

- 与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局。
- ZGC的Region具有动态性。
- 动态创建和销毁
- 动态的区域容量大小

### 具体分类

**小型Region（Small Region）**：容量固定为2MB，用于放置小于256KB的小对象。

**中型Region（Medium Region）**：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。

**大型Region（Large Region）**：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，所以实际容量可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。

## ZGC回收过程

与CMS中的ParNew和G1类似，ZGC也采用标记复制算法，不过该GC对该算法进行了重大改进：ZGC在标记、转移、重定位阶段几乎都是并发的，这也是ZGC实现停顿时间小于10ms目标的重要原因。

ZGC回收过程整体流程图：

![image-20230505113438594](https://gitee.com/stone-98/picture-bed/raw/master/202305051134031.png)

我们以3个对象A、B、C为例，演示ZGC的整个垃圾回收过程，GC Roots引用链如下所示：

![image-20230505104819923](https://gitee.com/stone-98/picture-bed/raw/master/202305051134241.png)

当对象进行初始化时，将会给Remappend进行着色。A、B、C对象都被标记为Remappend。

接下来进入垃圾回收~

### 初始标记

此阶段会发生STW，但是只对GC Roots的根对象进行标记，所以STW的时间也是非常短暂的，所以此时，A被标记为M0，B和C还是Remappend。

### 并发标记/对象重定位

此阶段GC线程和应用线程是并发的，此阶段会对GC Roots下所有的对象进行标记，所以此时，A、C都被标记为M0，因为B不可达所以还是Remappend。

### 重新标记

此阶段会发生STW，因为上一阶段GC线程和应用线程是并发执行的，所以可能出现误标记的情况，此阶段就是将他们的误标记进行修复，此阶段STW时间也是非常短暂的，例如如果B变为GC Roots可达了，则也需要将B对象标记为Remappend。

### 并发转移准备

此阶段GC线程和应用线程是并发的，此阶段就是通过特定的算法，算出回收哪个区域效率最高，

### 初始转移

 此阶段会发生STW，但是此阶段只会转移GC Roots的根对象，所以暂停时间也是非常短暂的。

### 并发转移

此阶段GC线程和应用线程是并发的，此阶段就是将所有GC Roots下的存活对象进行转移，所以耗时较长，因为此阶段GC线程和应用线程是并发的，所以会出现当对象地址转移之后，但是应用线程的引用指向的地址还是未转移之前的地址。

ZGC通过维护一张转发表和读屏障机制，解决了该问题。

转发表：记录老地址到新地址的变化

读屏障：类似于AOP的思想，在访问对象的地址时，触发读屏障，通过查询转发表修改引用指向新的地址，然后删除转发表的数据。当然此阶段会对性能有4%损耗。

如果此阶段没有应用线程对已经修改地址的对象进行访问的话，并发转移阶段也不会对引用的地址进行更新，将会在下一次GC的对象重定位阶段进行更新。

## ZGC的关键技术

上述说到，ZGC回收过程中的并发转移阶段，如果用户线程对对象进行访问，如果对象地址已经转移则触发读屏障，那么ZGC是如何判断对象地址转移的呢？

### 着色指针

> 32位系统最多只能支持4GB的内存，因为32位系统的地址总线只能寻址2^32（即4GB）的内存空间。即使安装了更多内存，32位系统也只能识别和使用其中的4GB。
>
> ZGC旨在为大型内存应用程序提供高效的垃圾回收服务。因为32位操作系统只能寻址4GB的内存空间，而大型内存应用程序通常需要更高的内存容量。64位操作系统支持更大的内存寻址空间，可以支持数百GB乃至数TB的内存容量，因此更适合用于大型内存应用程序和高性能计算。ZGC在设计时考虑了内存管理的需求，因此只支持64位操作系统。

**着色指针是一种将信息储存在指针中的技术。**

ZGC把64位虚拟机地址空间划分为多个子空间，如下图所示：

![image-20230515210743128](https://gitee.com/stone-98/picture-bed/raw/master/202305152107033.png)

其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。

当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。

与上述地址空间划分相对应的是，ZGC实际仅使用了64位地址空间的0~41位（可以寻址4TB的内存），而42~45位存储元数据，第47~63位固定为0。

![image-20230515211413219](https://gitee.com/stone-98/picture-bed/raw/master/202305152114938.png)

ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。

### 并发处理演示

接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：

- 初始化：ZGC初始化之后，整个内存的地址空间试图被设置为Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。
- 并发标记阶段：第一次进入标记阶段视图为M0，所以标记阶段结束后，对象的试图要么是M0，要么是Remapped，如果对象是M0试图，则说明对象是活跃的，如果对象是Remapped视图，说明对象是不活跃的。
- 并发转移阶段：标记结束后就进入转移阶段，此时地址试图再次被设置为Remapped。如果对象被GC线程或者应用线程访问过，那么就将对象的地址试图从M0设置为Remapped。

其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。**之所以设计成两个，是为了区别前一次标记和当前标记**。也即，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。

## 总结

ZGC是一款低延迟的垃圾回收期。

### 目标

- JDK推出的一款低延迟垃圾回收器
- 支持4TB级别的堆（JDK13已支持到了16TB）
- 停顿时间不会超过10ms，且不会随着堆的大小增加而增加



反正总结的话，就是通过这3个标记位判断对象是否需要被回收~先标记完成，然后转移还存活的对象，

## 参考

- https://it-blog-cn.com/blogs/jvm/zgc.html#%E4%BA%94%E3%80%81zgc%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B
- https://pdai.tech/md/java/jvm/java-jvm-gc-zgc.html
- https://zhuanlan.zhihu.com/p/105921339   

