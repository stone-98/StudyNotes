## 背景

ZGC收集器（Z Garbage Collector）是由Oracle公司研发的。2018年创建了JEP 333将ZGC提交给OpenJDK，推动其进入OpenJDK11的发布清单中。

## 介绍

ZGC垃圾收集器是一款基于Region内存布局的，暂未设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，以低延迟为首要目标的一款垃圾收集器。

## 实现目标

- JDK推出的一款低延迟垃圾回收器
- 支持4TB级别的堆（JDK13已支持到了16TB）
- 停顿时间不会超过10ms，且不会随着堆的大小增加而增加

## ZGC的堆内存布局

- 与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局。
- ZGC的Region具有动态性。
- 动态创建和销毁
- 动态的区域容量大小

### 具体分类

**小型Region（Small Region）**：容量固定为2MB，用于放置小于256KB的小对象。

**中型Region（Medium Region）**：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。

**大型Region（Large Region）：**容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，所以实际容量可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。



## ZGC回收过程

ZGC回收过程整体流程图：

![image-20230505113438594](https://gitee.com/stone-98/picture-bed/raw/master/202305051134031.png)

我们以3个对象A、B、C为例，演示ZGC的整个垃圾回收过程，GC Roots引用链如下所示：

![image-20230505104819923](https://gitee.com/stone-98/picture-bed/raw/master/202305051134241.png)

当对象进行初始化时，将会给Remappend进行着色。A、B、C对象都被标记为Remappend。

接下来进入垃圾回收~

### 初始标记

此阶段会发生STW，但是只对GC Roots的根对象进行标记，所以STW的时间也是非常短暂的，所以此时，A被标记为M0，B和C还是Remappend。

### 并发标记/对象重定位

此阶段GC线程和应用线程是并发的，此阶段会对GC Roots下所有的对象进行标记，所以此时，A、C都被标记为M0，因为B不可达所以还是Remappend。

### 重新标记

此阶段会发生STW，因为上一阶段GC线程和应用线程是并发执行的，所以可能出现误标记的情况，此阶段就是将他们的误标记进行修复，此阶段STW时间也是非常短暂的，例如如果B变为GC Roots可达了，则也需要将B对象标记为Remappend。

### 并发转移准备

此阶段GC线程和应用线程是并发的，此阶段就是通过特定的算法，算出回收哪个区域效率最高，

### 初始转移

 此阶段会发生STW，但是此阶段只会转移GC Roots的根对象，所以暂停时间也是非常短暂的。

### 并发转移

此阶段GC线程和应用线程是并发的，此阶段就是将所有GC Roots下的存活对象进行转移，所以耗时较长，因为此阶段GC线程和应用线程是并发的，所以会出现当对象地址转移之后，但是应用线程的引用指向的地址还是未转移之前的地址。

ZGC通过维护一张转发表和读屏障机制，解决了该问题。

转发表：记录老地址到新地址的变化

读屏障：类似于AOP的思想，在访问对象的地址时，触发读屏障，通过查询转发表修改引用指向新的地址，然后删除转发表的数据。当然此阶段会对性能有4%损耗。

如果此阶段没有应用线程对已经修改地址的对象进行访问的话，并发转移阶段也不会对引用的地址进行更新，将会在下一次GC的对象重定位阶段进行更新。

TODO 其实感觉对这个m0和m1以及remapped的试图流转有些不解暂时不去关注了，以后再看。

反正总结的话，就是通过这3个标记位判断对象是否需要被回收~先标记完成，然后转移还存活的对象，

